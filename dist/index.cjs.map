{"version":3,"sources":["../src/lib/assertions.ts","../src/lib/transforms.ts","../src/string-transform.ts","../src/assert-that.ts"],"names":["addStep","anagram","steps","currentValue","api","tryFn","handleStepError","evaluateStep"],"mappings":"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","file":"index.cjs","sourcesContent":["/** biome-ignore-all lint/performance/useTopLevelRegex: <Inline regex is ok for a regex based library, after all it's not in userland> */\nimport { addStep } from \"../assert-that\";\n\ntype PhonePreset = \"UG\" | \"US\" | \"DEFAULT\";\n\n/**\n * Checks if value contains substring `str`.\n * @param str The substring to look for.\n * @returns API for chaining.\n */\nfunction has(str: string) {\n  return addStep(\"has\", (v) => v.includes(str));\n}\n\n/**\n * Checks if value does NOT contain substring `str`.\n * @param str The substring to exclude.\n * @returns API for chaining.\n */\nfunction doesNotHave(str: string) {\n  return addStep(\"doesNotHave\", (v) => !v.includes(str));\n}\n\n/**\n * Checks if value starts with substring `str`.\n * @param str The prefix to check.\n * @returns API for chaining.\n */\nfunction startsWith(str: string) {\n  return addStep(\"startsWith\", (v) => v.startsWith(str));\n}\n\n/**\n * Checks if value ends with substring `str`.\n * @param str The suffix to check.\n * @returns API for chaining.\n */\nfunction endsWith(str: string) {\n  return addStep(\"endsWith\", (v) => v.endsWith(str));\n}\n\n/**\n * Checks for exact string match.\n * @param str The value to match exactly.\n * @returns API for chaining.\n */\nfunction isExactly(str: string) {\n  return addStep(\"isExactly\", (v) => v === str);\n}\n\n/**\n * Checks if all characters are letters (A-Z, a-z).\n * @returns API for chaining.\n */\nfunction isAlpha() {\n  return addStep(\"isAlpha\", (v) => /^[A-Za-z]+$/.test(v));\n}\n\n/**\n * Checks if all characters are letters or digits (A-Z, a-z, 0-9).\n * @returns API for chaining.\n */\nfunction isAlphaNumeric() {\n  return addStep(\"isAlphaNumeric\", (v) => /^[A-Za-z0-9]+$/.test(v));\n}\n\n/**\n * Checks if all letters are uppercase.\n * @returns API for chaining.\n */\nfunction hasAllUppercase() {\n  return addStep(\"hasAllUppercase\", (v) =>\n    /^[A-Z]+$/.test(v.replace(/[^A-Za-z]/g, \"\")),\n  );\n}\n\n/**\n * Checks if all letters are lowercase.\n * @returns API for chaining.\n */\nfunction hasAllLowercase() {\n  return addStep(\"hasAllLowercase\", (v) =>\n    /^[a-z]+$/.test(v.replace(/[^A-Za-z]/g, \"\")),\n  );\n}\n\n/**\n * Checks if value contains at least one uppercase letter.\n * @returns API for chaining.\n */\nfunction isUpperCase() {\n  return addStep(\"isUpperCase\", (v) => /[A-Z]/.test(v));\n}\n\n/**\n * Checks if value contains at least one lowercase letter.\n * @returns API for chaining.\n */\nfunction isLowerCase() {\n  return addStep(\"isLowerCase\", (v) => /[a-z]/.test(v));\n}\n\n/**\n * Checks if all characters are digits.\n * @returns API for chaining.\n */\nfunction isDigit() {\n  return addStep(\"isDigit\", (v) => /^\\d+$/.test(v));\n}\n\n/**\n * Checks if string is number-convertible (parseable as number).\n * @returns API for chaining.\n */\nfunction isNumeric() {\n  return addStep(\"isNumeric\", (v) => !Number.isNaN(Number(v)));\n}\n\n/**\n * Checks if all characters are whitespace.\n * @returns API for chaining.\n */\nfunction isWhitespace() {\n  return addStep(\"isWhitespace\", (v) => /^\\s+$/.test(v));\n}\n\n/**\n * Checks if the value is a valid email address.\n * @returns API for chaining.\n */\nfunction isEmail() {\n  return addStep(\"isEmail\", (v) => /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(v));\n}\n\n/**\n * Checks if the value is a valid HTTP/HTTPS URL.\n * @returns API for chaining.\n */\nfunction isUrl() {\n  return addStep(\"isUrl\", (v) =>\n    /^(https?:\\/\\/)?([a-zA-Z0-9\\-_]+\\.)+[a-zA-Z]{2,}(:\\d+)?(\\/.*)?$/.test(v),\n  );\n}\n\n/**\n * Checks if value contains only URL-safe characters.\n * @returns API for chaining.\n */\nfunction isUrlSafe() {\n  return addStep(\"isUrlSafe\", (v) => /^[a-zA-Z0-9\\-._~]+$/.test(v));\n}\n\n/**\n * Checks if value is a valid phone number for a given preset.\n * @param preset \"UG\" for Uganda, \"US\" for United States, \"DEFAULT\" for generic.\n * @returns API for chaining.\n */\nfunction isPhone(preset: PhonePreset) {\n  return addStep(\"isPhone\", (v) => {\n    if (preset === \"UG\") {\n      return /^(\\+256|0)7\\d{8}$/.test(v);\n    }\n    if (preset === \"US\") {\n      const digits = v.replace(/\\D/g, \"\");\n      return (\n        digits.length === 10 || (digits.length === 11 && digits.startsWith(\"1\"))\n      );\n    }\n    return false;\n  });\n}\n\n/**\n * Checks if value is convertible to number.\n * @returns API for chaining.\n */\nfunction isNumberConvertible() {\n  return addStep(\"isNumberConvertible\", (v) => !Number.isNaN(Number(v)));\n}\n\n/**\n * Checks value with a custom regular expression.\n * @param regex Regular expression to test.\n * @returns API for chaining.\n */\nfunction passesRegex(regex: RegExp) {\n  return addStep(\"passesRegex\", (v) => regex.test(v));\n}\n\n/**\n * Checks that value does NOT match the provided regex.\n * @param regex Regular expression to test.\n * @returns API for chaining.\n */\nfunction failsRegex(regex: RegExp) {\n  return addStep(\"failsRegex\", (v) => !regex.test(v));\n}\n\n/**\n * Checks if value is exactly equal to any of the provided values.\n * @param values List of values to match.\n * @returns API for chaining.\n */\nfunction anyOf(...values: string[]) {\n  return addStep(\"anyOf\", (v) => values.includes(v));\n}\n\n/**\n * Checks that value's length equals n, or is within {min, max} bounds.\n * @param nOrObj Number or object with min/max.\n * @returns API for chaining.\n */\nfunction lengthIs(nOrObj: number | { min?: number; max?: number }) {\n  return addStep(\"lengthIs\", (v) => {\n    const len = v.length;\n    if (typeof nOrObj === \"number\") {\n      return len === nOrObj;\n    }\n    let ok = true;\n    if (nOrObj.min !== undefined) {\n      ok = ok && len >= nOrObj.min;\n    }\n    if (nOrObj.max !== undefined) {\n      ok = ok && len <= nOrObj.max;\n    }\n    return ok;\n  });\n}\n\n/**\n * Checks if a substring exists between two markers (prefix and suffix).\n * Returns true if there is a substring between prefix and suffix.\n * @param prefix Prefix string.\n * @param suffix Suffix string.\n * @returns API for chaining.\n */\nfunction isBetween(prefix: string, suffix: string) {\n  return addStep(\"isBetween\", (v) => {\n    const prefixIdx = v.indexOf(prefix);\n    const suffixIdx = v.indexOf(suffix, prefixIdx + prefix.length);\n    return (\n      prefixIdx !== -1 &&\n      suffixIdx !== -1 &&\n      prefixIdx + prefix.length < suffixIdx\n    );\n  });\n}\n\n/**\n * Checks if value has no emoji characters.\n * @returns API for chaining.\n */\nfunction hasNoEmoji() {\n  return addStep(\"hasNoEmoji\", (v) => !/[\\u{1F600}-\\u{1F64F}]/u.test(v));\n}\n\n/**\n * Checks if value is an anagram of the given string.\n * @param str The string to compare as an anagram.\n * @returns API for chaining.\n */\nfunction anagram(str: string) {\n  const sorted = (s: string) =>\n    s\n      .split(\"\")\n      .sort((a, b) => a.localeCompare(b))\n      .join(\"\");\n  return addStep(\"anagram\", (v) => sorted(v) === sorted(str));\n}\n\n/**\n * Checks if value is a palindrome (ignoring spaces and case).\n * @returns API for chaining.\n */\nfunction isPalindrome() {\n  return addStep(\"isPalindrome\", (v) => {\n    const cleaned = v.replace(/[\\W_]/g, \"\").toLowerCase();\n    return cleaned === cleaned.split(\"\").reverse().join(\"\");\n  });\n}\n\n/**\n * Checks if all characters in value are unique.\n * @returns API for chaining.\n */\nfunction hasUniqueCharacters() {\n  return addStep(\"hasUniqueCharacters\", (v) => new Set(v).size === v.length);\n}\n\n/**\n * Checks value at position `idx` against supplied value.\n * @param idx Index to check.\n * @returns Object with .is(value) assertion for chaining.\n */\nfunction whereValueAt(idx: number) {\n  return {\n    /**\n     * Checks if character at index equals value.\n     * @param val Value to compare.\n     * @returns API for chaining.\n     */\n    is: (val: string) =>\n      addStep(`whereValueAt(${idx}).is`, (v) => v[idx] === val),\n  };\n}\n\n/**\n * Returns an API for word count checks.\n * @returns Object with .is(count) assertion for chaining.\n */\nfunction wordCount() {\n  return {\n    /**\n     * Checks if word count matches n.\n     * @param n Expected word count.\n     * @returns API for chaining.\n     */\n    is: (n: number) =>\n      addStep(\n        \"wordCount.is\",\n        (v) => v.trim().split(/\\s+/).filter(Boolean).length === n,\n      ),\n  };\n}\n\n/**\n * Checks if value is valid Base64.\n * @returns API for chaining.\n */\nfunction isBase64() {\n  return addStep(\"isBase64\", (v) =>\n    /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(v),\n  );\n}\n\n/**\n * Checks if value meets strong password criteria.\n * At least 8 chars, uppercase, lowercase, number, and special.\n * @returns API for chaining.\n */\nfunction isStrongPassword() {\n  return addStep(\"isStrongPassword\", (v) =>\n    /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*\\W).{8,}$/.test(v),\n  );\n}\n\nexport const assertions = {\n  has,\n  doesNotHave,\n  startsWith,\n  endsWith,\n  isExactly,\n  isAlpha,\n  isAlphaNumeric,\n  hasAllUppercase,\n  hasAllLowercase,\n  isUpperCase,\n  isLowerCase,\n  isDigit,\n  isNumeric,\n  isWhitespace,\n  isEmail,\n  isUrl,\n  isUrlSafe,\n  isPhone,\n  isNumberConvertible,\n  passesRegex,\n  failsRegex,\n  anyOf,\n  lengthIs,\n  isBetween,\n  hasNoEmoji,\n  anagram,\n  isPalindrome,\n  hasUniqueCharacters,\n  whereValueAt,\n  wordCount,\n  isBase64,\n  isStrongPassword,\n};\n\n// add \"hasSameEditDistance\"\n","/** biome-ignore-all lint/performance/useTopLevelRegex: <Inline regex is ok for a regex based library, after all it's not in userland> */\nimport { addStep } from \"../string-transform\";\n\n/**\n * Converts all characters in the string to uppercase.\n * @returns API for chaining.\n */\nfunction toUpperCase() {\n  return addStep(\"toUpperCase\", (v: string) => v.toUpperCase());\n}\n\n/**\n * Converts all characters in the string to lowercase.\n * @returns API for chaining.\n */\nfunction toLowerCase() {\n  return addStep(\"toLowerCase\", (v: string) => v.toLowerCase());\n}\n\n/**\n * Converts the string to PascalCase (every word capitalized, no delimiters).\n * @returns API for chaining.\n */\nfunction toPascalCase() {\n  return addStep(\"toPascalCase\", (v: string) =>\n    v\n      .replace(/(\\w)(\\w*)/g, (_, g1, g2) => g1.toUpperCase() + g2.toLowerCase())\n      .replace(/[\\s_-]+/g, \"\"),\n  );\n}\n\n/**\n * Converts the string to snake_case.\n * @returns API for chaining.\n */\nfunction toSnakeCase() {\n  return addStep(\"toSnakeCase\", (v: string) =>\n    v\n      .replace(/\\s+/g, \"_\")\n      .replace(/([a-z\\d])([A-Z])/g, \"$1_$2\")\n      .replace(/-+/g, \"_\")\n      .replace(/__+/g, \"_\")\n      .toLowerCase(),\n  );\n}\n\n/**\n * Converts the string to camelCase.\n * @returns API for chaining.\n */\nfunction toCamelCase() {\n  return addStep(\"toCamelCase\", (v: string) =>\n    v\n      .replace(/[-_\\s]+(.)?/g, (_, c) => (c ? c.toUpperCase() : \"\"))\n      .replace(/^(.)/, (m) => m.toLowerCase()),\n  );\n}\n\n/**\n * Trims whitespace from the beginning and end of the string.\n * @returns API for chaining.\n */\nfunction trim() {\n  return addStep(\"trim\", (v: string) => v.trim());\n}\n\n/**\n * Splits the string into parts using the given separator, then allows you to pick a specific part or join the parts back.\n * @param splitter Separator string or RegExp.\n * @returns Object with takeThatAt and join methods for further chaining.\n */\nfunction split(splitter?: string | RegExp) {\n  return {\n    /**\n     * Picks the part at the given index after splitting.\n     * @param index Index of part to select.\n     * @returns API for chaining.\n     */\n    takeThatAt(index: number) {\n      return addStep(\"takeThatAt\", (v: string) => {\n        const arr = v.split(splitter ?? \"\");\n        if (index < 0 || index >= arr.length) {\n          throw new Error(\"Index out of range\");\n        }\n        return arr[index];\n      });\n    },\n    /**\n     * Joins all parts after splitting using the given separator (default is empty string).\n     * @param sep String to use between joined parts.\n     * @returns API for chaining.\n     */\n    join(sep = \"\") {\n      return addStep(\"join\", (v: string) => v.split(splitter ?? \"\").join(sep));\n    },\n  };\n}\n\n/**\n * Converts the string to its hexadecimal character codes.\n * @returns API for chaining.\n */\nfunction toHex() {\n  return addStep(\"toHex\", (v: string) =>\n    Array.from(v)\n      .map((c) => c.charCodeAt(0).toString(16).padStart(2, \"0\"))\n      .join(\"\"),\n  );\n}\n\n/**\n * Converts the string to its binary character codes.\n * @returns API for chaining.\n */\nfunction toBinary() {\n  return addStep(\"toBinary\", (v: string) =>\n    Array.from(v)\n      .map((c) => c.charCodeAt(0).toString(2).padStart(8, \"0\"))\n      .join(\" \"),\n  );\n}\n\n/**\n * Encodes the string using encodeURIComponent (URL-safe encoding).\n * @returns API for chaining.\n */\nfunction toURLSafe() {\n  return addStep(\"toURLSafe\", (v: string) => encodeURIComponent(v));\n}\n\n/**\n * Gets the character at the given index in the string.\n * @param index The position of the character to get.\n * @returns API for chaining.\n */\nfunction getCharacterAt(index: number) {\n  return addStep(\"getCharacterAt\", (v: string) => v.charAt(index));\n}\n\n/**\n * Gets a random character from the string.\n * @returns API for chaining.\n */\nfunction getRandomFrom() {\n  return addStep(\"getRandomFrom\", (v: string) =>\n    v.charAt(Math.floor(Math.random() * v.length)),\n  );\n}\n\n/**\n * Removes spaces, digits, or special characters from the string, depending on options.\n * @param opts Sanitization options.\n * @returns API for chaining.\n */\nfunction sanitize(opts?: {\n  removeSpaces?: boolean;\n  removeDigits?: boolean;\n  removeSpecial?: boolean;\n}) {\n  return addStep(\"sanitize\", (v: string) => {\n    let s = v;\n    if (opts?.removeSpaces) {\n      s = s.replace(/\\s+/g, \"\");\n    }\n    if (opts?.removeDigits) {\n      s = s.replace(/\\d+/g, \"\");\n    }\n    if (opts?.removeSpecial) {\n      s = s.replace(/[^\\w\\s]/g, \"\");\n    }\n    return s;\n  });\n}\n\n/**\n * Sorts the characters of this string together with another string, producing a new sorted string.\n * @param str Another string to mix in.\n * @returns API for chaining.\n */\nfunction anagram(str: string) {\n  return addStep(\"anagram\", (v: string) =>\n    [...v, ...str].sort((a, b) => a.localeCompare(b)).join(\"\"),\n  );\n}\n\n/**\n * Replaces the first occurrence of a substring or pattern with a replacement string.\n * @param search String or RegExp to search for.\n * @param rep Replacement string.\n * @returns API for chaining.\n */\nfunction replace(search: string | RegExp, rep: string) {\n  return addStep(\"replace\", (v: string) => v.replace(search, rep));\n}\n\n/**\n * Replaces all occurrences of a substring or pattern with a replacement string.\n * @param search String or RegExp to search for.\n * @param rep Replacement string.\n * @returns API for chaining.\n */\nfunction replaceAll(search: string | RegExp, rep: string) {\n  return addStep(\"replaceAll\", (v: string) => {\n    if (typeof search === \"string\") {\n      return v.split(search).join(rep);\n    }\n    return v.replace(new RegExp(search, \"g\"), rep);\n  });\n}\n\n/**\n * Removes the first occurrence of a substring or pattern from the string.\n * @param what String or RegExp to remove.\n * @returns API for chaining.\n */\nfunction removeFirst(what: string | RegExp) {\n  return addStep(\"removeFirst\", (v: string) => v.replace(what, \"\"));\n}\n\n/**\n * Removes all occurrences of a substring or pattern from the string.\n * @param what String or RegExp to remove.\n * @returns API for chaining.\n */\nfunction removeAll(what: string | RegExp) {\n  return addStep(\"removeAll\", (v: string) =>\n    typeof what === \"string\"\n      ? v.split(what).join(\"\")\n      : v.replace(new RegExp(what, \"g\"), \"\"),\n  );\n}\n\n/**\n * Adds a prefix and/or suffix to the string.\n * @param prefixOrSuffix Prefix/suffix object or string.\n * @returns API for chaining.\n */\nfunction add(prefixOrSuffix: { prefix?: string; suffix?: string } | string) {\n  return addStep(\"add\", (v: string) => {\n    if (typeof prefixOrSuffix === \"string\") {\n      return prefixOrSuffix + v;\n    }\n    let result = v;\n    if (prefixOrSuffix.prefix) {\n      result = prefixOrSuffix.prefix + result;\n    }\n    if (prefixOrSuffix.suffix) {\n      result += prefixOrSuffix.suffix;\n    }\n    return result;\n  });\n}\n\n/**\n * Pads the string to the specified length, using the provided character and location.\n * @param len Desired total length.\n * @param char Character to use for padding.\n * @param where Where to pad: 'start', 'end', or 'both'.\n * @returns API for chaining.\n */\nfunction pad(len: number, char = \" \", where: \"start\" | \"end\" | \"both\" = \"end\") {\n  return addStep(\"pad\", (v: string) => {\n    if (where === \"start\") {\n      return v.padStart(len, char);\n    }\n    if (where === \"end\") {\n      return v.padEnd(len, char);\n    }\n    const totalPad = len - v.length;\n    if (totalPad > 0) {\n      const padStartLen = Math.floor(totalPad / 2);\n      const padEndLen = totalPad - padStartLen;\n      return char.repeat(padStartLen) + v + char.repeat(padEndLen);\n    }\n    return v;\n  });\n}\n\n/**\n * Shuffles the characters in the string randomly.\n * @returns API for chaining.\n */\nfunction randomize() {\n  return addStep(\"randomize\", (v: string) =>\n    v\n      .split(\"\")\n      .sort(() => Math.random() - 0.5)\n      .join(\"\"),\n  );\n}\n\n/**\n * Chunks the string into parts of the given size, separated by the given separator.\n * @param size Length of each chunk (how many characters per part).\n * @param sep Separator string to use between chunks (default is '|').\n * @returns API for chaining.\n */\nfunction chunk(size: number, sep = \"|\") {\n  return addStep(\"chunk\", (v: string) => {\n    const arr = v.split(\"\");\n    const chunks: string[] = [];\n    for (let i = 0; i < arr.length; i += size) {\n      chunks.push(arr.slice(i, i + size).join(\"\"));\n    }\n    return chunks.join(sep);\n  });\n}\n\n/**\n * Breaks the string into lines of a given length, separated by newlines.\n * @param charactersPerLine Number of characters per line.\n * @returns API for chaining.\n */\nfunction breakToLines(charactersPerLine: number) {\n  return addStep(\"breakToLines\", (v: string) => {\n    let out = \"\";\n    for (let i = 0; i < v.length; i += charactersPerLine) {\n      out += v.substring(i, i + charactersPerLine);\n      if (i + charactersPerLine < v.length) {\n        out += \"\\n\";\n      }\n    }\n    return out;\n  });\n}\n\n/**\n * Extracts the first match for a pattern.\n * @param pattern Pattern to match (string or RegExp).\n * @returns API for chaining.\n * @throws If no match found.\n */\nfunction extract(pattern: string | RegExp) {\n  return addStep(\"extract\", (v: string) => {\n    const matches = new RegExp(pattern).exec(v);\n    if (!matches) {\n      throw new Error(\"No match found\");\n    }\n    return matches[0];\n  });\n}\n\n/**\n * Extracts a substring using start and end indexes.\n * @param start Index to start extraction.\n * @param end Index to end extraction (exclusive).\n * @returns API for chaining.\n */\nfunction extractInRange(start: number, end: number) {\n  return addStep(\"extractInRange\", (v: string) => v.slice(start, end));\n}\n\n/**\n * Extracts the substring between two markers.\n * @param prefix The start marker.\n * @param suffix The end marker.\n * @returns API for chaining.\n * @throws If not found.\n */\nfunction extractWhenBetween(prefix: string, suffix: string) {\n  return addStep(\"extractWhenBetween\", (v: string) => {\n    const startIdx = v.indexOf(prefix);\n    const endIdx = v.indexOf(suffix, startIdx + prefix.length);\n    if (startIdx === -1 || endIdx === -1 || endIdx <= startIdx) {\n      throw new Error(\"Not found\");\n    }\n    return v.slice(startIdx + prefix.length, endIdx);\n  });\n}\n\n/**\n * Escapes regex special characters in the string.\n * @returns API for chaining.\n */\nfunction escapeString() {\n  return addStep(\"escapeString\", (v: string) =>\n    v.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\"),\n  );\n}\n\n/**\n * Unescapes regex special characters in the string.\n * @returns API for chaining.\n */\nfunction unEscapeString() {\n  return addStep(\"unEscapeString\", (v: string) =>\n    v.replace(/\\\\([-/\\\\^$*+?.()|[\\]{}])/g, \"$1\"),\n  );\n}\n\n/**\n * Hashes the string using the djb2 algorithm.\n * @returns API for chaining.\n */\nfunction toHash() {\n  return addStep(\"toHash\", (v: string) => {\n    let hash = 5381;\n    for (let i = 0; i < v.length; i++) {\n      // biome-ignore lint/nursery/noBitwiseOperators: <this is ok for djb2 algorithm implementation>\n      hash = (hash << 5) + hash + v.charCodeAt(i);\n    }\n    return hash.toString();\n  });\n}\n\nexport const transforms = {\n  toUpperCase,\n  toLowerCase,\n  toPascalCase,\n  toSnakeCase,\n  toCamelCase,\n  trim,\n  split,\n  toHex,\n  toBinary,\n  toURLSafe,\n  getCharacterAt,\n  getRandomFrom,\n  sanitize,\n  anagram,\n  replace,\n  replaceAll,\n  removeFirst,\n  removeAll,\n  add,\n  pad,\n  randomize,\n  chunk,\n  breakToLines,\n  extract,\n  extractInRange,\n  extractWhenBetween,\n  escapeString,\n  unEscapeString,\n  toHash,\n};\n","/**\n * Regist: Human-friendly, chainable string transformation API.\n * Lazy transformation API, evaluated only on .try().\n * Author: Hussein Kizz.\n *\n * - All transformation methods return the API for chaining.\n * - .try() triggers evaluation of the chain.\n * - If all transformations succeed, .try() returns the final value.\n * - If a transformation throws and a handler is passed to .try(handler), handler is called with (error, step, valueSoFar) and .try() returns null.\n * - If an error occurs and no handler is passed, the error is thrown.\n * - After .try(), further chaining is not allowed.\n */\n\nimport { assertThat } from \"./assert-that\";\nimport { transforms } from \"./lib/transforms\";\n\ntype Step = { name: string; fn: (value: string) => string };\n\n// working state (module-level, must be reset for each chain)\nconst steps: Step[] = [];\nlet currentValue = \"\";\n\nconst api = {\n  ...transforms,\n  customTransform,\n  try: tryFn,\n  assertThat: assertThatStart,\n};\n\nexport type TransformApi = {\n  [K in keyof typeof api]: (typeof api)[K];\n};\n\n/**\n * Adds a step to the current transformation chain.\n * @param name Name of the transformation step.\n * @param fn Transform function that receives the value and returns a string.\n * @returns API for chaining.\n */\nexport function addStep(name: string, fn: (value: string) => string) {\n  steps.push({ name, fn });\n  return api as TransformApi;\n}\n\n/**\n * Applies a custom transformation to the value.\n * @param fn Transformation function.\n * @returns API for chaining.\n * @throws If the function does not return a string or throws unless try chained on with a handler passed to it.\n */\nfunction customTransform(fn: (val: string) => string) {\n  return addStep(\"customTransform\", (v: string) => {\n    let result: string;\n    try {\n      result = fn(v);\n    } catch (e) {\n      throw new Error(`Custom transform function failed: ${e}`);\n    }\n    if (typeof result !== \"string\") {\n      throw new Error(\n        `Custom transform function must return a string, but returned ${JSON.stringify(result)}`,\n      );\n    }\n    return result;\n  });\n}\n\n/**\n * Handles an error thrown during evaluation of a step.\n * @param err The thrown error or value.\n * @param handler Optional error handler (error, step, valueSoFar).\n * @param name The name of the step.\n * @param lastStepValue The value at the point of failure.\n * @returns null (if a handler was provided).\n * @throws The error, if no handler is provided.\n */\nfunction handleStepError(\n  err: unknown,\n  handler:\n    | ((error: Error, step: string, valueSoFar: string) => void)\n    | undefined,\n  name: string,\n  lastStepValue: string,\n): null {\n  if (handler) {\n    handler(\n      err instanceof Error ? err : new Error(String(err)),\n      name,\n      lastStepValue,\n    );\n    return null;\n  }\n  throw err;\n}\n\n/**\n * Evaluates a single transformation step.\n * @param fn The transformation function for the step.\n * @param valueSoFar The string value to transform.\n * @returns The result string.\n */\nfunction evaluateStep(\n  fn: (value: string) => string,\n  valueSoFar: string,\n): string {\n  return fn(valueSoFar);\n}\n\n/**\n * Triggers evaluation of the transformation chain.\n * @param handler Optional error handler (error: Error, step: string, valueSoFar: string) => void\n * @returns {string|null} result string (all succeed), or null (error handled)\n * @example\n * const result = stringTransform(\"fooBar\")\n *   .toUpperCase()\n *   .try(); // returns \"FOOBAR\"\n *\n * const result2 = stringTransform(\"fooBar\")\n *   .customTransform(() => { throw new Error(\"Oops!\"); })\n *   .try((error, step, valueSoFar) => {\n *     console.error(error, step, valueSoFar);\n *   }); // doesn't throw, passes error to handler and returns null.\n */\nfunction tryFn(\n  handler?: (error: Error, step: string, valueSoFar: string) => void,\n): string | null {\n  let value = currentValue;\n  for (const { name, fn } of steps) {\n    try {\n      value = evaluateStep(fn, value);\n    } catch (error) {\n      return handleStepError(error, handler, name, value);\n    }\n  }\n  return value;\n}\n\n/**\n * Switches to the assertion chain for further validation.\n * Runs try on the current chain, throws if an error occurs, otherwise switches to assert api.\n * If an error occurs, throws with detailed info from try.\n * @returns assertThat API.\n */\nfunction assertThatStart() {\n  let errorInfo: { error: Error; step: string; valueSoFar: string } | null =\n    null;\n  const result = tryFn((error, step, valueSoFar) => {\n    errorInfo = { error, step, valueSoFar };\n  });\n  if (result === null && errorInfo) {\n    const { error, step, valueSoFar } = errorInfo as {\n      error: Error;\n      step: string;\n      valueSoFar: string;\n    };\n    throw new Error(\n      `Transformation failed at step \"${step}\": ${error.message}\\nValue so far: ${valueSoFar}`,\n    );\n  }\n  return assertThat(result as string);\n}\n\n/**\n * Initiates a Regist transformation API for string manipulation.\n *\n * @param stringToTransform The string to transform.\n * @returns An API with transformation methods for chaining.\n *\n * @example\n * stringTransform(\"foo\")\n *   .toUpperCase()\n *   .try();\n * // → \"FOO\"\n *\n * @example\n * stringTransform(\" fooBar \")\n *   .trim()\n *   .toSnakeCase()\n *   .try();\n * // → \"foo_bar\"\n *\n * @example\n * stringTransform(\"fooBar\")\n *   .customTransform(val => { throw new Error(\"fail!\"); })\n *   .try((err, step, valueSoFar) => {\n *     console.error(err, step, valueSoFar);\n *   }); // handles error and returns null\n */\nexport function stringTransform(stringToTransform: string) {\n  // reset working state for new transformation chain\n  steps.length = 0;\n  currentValue = stringToTransform;\n  return api;\n}\n","/**\n * Regist: Human-friendly, chainable string assertion API.\n * Lazy assertion API, evaluated only on .try().\n * Author: Hussein Kizz.\n *\n * - All assertion methods return the API for chaining.\n * - .try() triggers evaluation of the chain.\n * - If all assertions pass, .try() returns true.\n * - If an assertion fails, .try() returns false.\n * - If an error occurs and a handler is passed to .try(handler), handler is called with (error, step, valueSoFar) and .try() returns null.\n * - If an error occurs and no handler is passed, the error is thrown.\n * - After .try(), further chaining is not allowed.\n */\n\nimport { assertions } from \"./lib/assertions\";\nimport { stringTransform } from \"./string-transform\";\n\ntype Step = { name: string; fn: (value: string) => boolean };\n\n// working state (module-level, must be reset for each assertion chain)\nconst steps: Step[] = [];\nlet _negate = false;\nlet currentValue = \"\";\n\nconst api = {\n  ...assertions,\n  isNot,\n  customCheck,\n  try: tryFn,\n  stringTransform: stringTransformStart,\n};\n\nexport type AssertApi = {\n  [K in keyof typeof api]: (typeof api)[K];\n};\n\n/**\n * Negates the next assertion in the chain.\n * @returns API for chaining.\n */\nfunction isNot() {\n  _negate = true;\n  return api as AssertApi;\n}\n\n/**\n * Adds a step to the current assertion chain.\n * @param name Name of the assertion step.\n * @param fn Predicate function that receives the value and returns boolean.\n * @returns API for chaining.\n */\nexport function addStep(name: string, fn: (value: string) => boolean) {\n  steps.push({ name, fn });\n  return api as AssertApi;\n}\n\n/**\n * Checks value with a custom predicate function.\n * Predicate must return a boolean, otherwise throws.\n * @param fn Predicate.\n * @returns API for chaining.\n */\nfunction customCheck(fn: (str: string) => boolean) {\n  return addStep(\"customCheck\", (v) => {\n    let result: unknown = null;\n    try {\n      result = fn(v);\n    } catch (e) {\n      throw new Error(`Error evaluating predicate: ${e}`);\n    }\n    if (typeof result !== \"boolean\") {\n      throw new Error(\"Custom check function must return a boolean\");\n    }\n    return result;\n  });\n}\n\n/**\n * Handles an error thrown during evaluation of a step.\n * @param err The thrown error or value.\n * @param handler Optional error handler (error, step, valueSoFar).\n * @param name The name of the assertion step.\n * @param lastStepValue The value at the point of failure.\n * @returns null (if a handler was provided).\n * @throws The error, if no handler is provided.\n */\nfunction handleStepError(\n  err: unknown,\n  handler:\n    | ((error: Error, step: string, valueSoFar: string) => void)\n    | undefined,\n  name: string,\n  lastStepValue: string,\n): null {\n  if (handler) {\n    handler(\n      err instanceof Error ? err : new Error(String(err)),\n      name,\n      lastStepValue,\n    );\n    return null;\n  }\n  throw err;\n}\n\n/**\n * Evaluates a single assertion step.\n * @param fn The predicate function for the step.\n * @param valueSoFar The string value to test.\n * @param negate Whether to negate the result.\n * @returns Boolean result of test (possibly negated).\n */\nfunction evaluateStep(\n  fn: (value: string) => boolean,\n  valueSoFar: string,\n  negate: boolean,\n): boolean {\n  let result = fn(valueSoFar);\n  if (negate) {\n    result = !result;\n    _negate = false;\n  }\n  return result;\n}\n\n/**\n * Triggers evaluation of the assertion chain.\n * @param handler Optional error handler (error: Error, step: string, valueSoFar: string) => void\n * @returns {boolean|null} true (all pass), false (assertion failed), or null (error handled)\n * @example\n * const result = assertThat(\"fooBar\")\n *   .has(\"Bar\")\n *   .isAlpha()\n *   .try(); // throws if any error happens and returns null.\n *\n * const result2 = assertThat(\"fooBar\")\n *   .customCheck(() => { throw new Error(\"Oops!\"); })\n *   .try((error, step, valueSoFar) => {\n *     console.error(error, step, valueSoFar);\n *   }); // doesn't throw, passes error to handler and returns null.\n */\nfunction tryFn(\n  handler?: (error: Error, step: string, valueSoFar: string) => void,\n): true | false | null {\n  const value = currentValue;\n  const valueSoFar = value;\n  for (const { name, fn } of steps) {\n    try {\n      const result = evaluateStep(fn, valueSoFar, _negate);\n      if (!result) {\n        return false;\n      }\n    } catch (error) {\n      return handleStepError(error, handler, name, valueSoFar);\n    }\n  }\n  return true;\n}\n\n/**\n * Switches to the stringTransform chain for further manipulation.\n * Runs try on the current assertion chain, throws if an error occurs, otherwise switches to stringTransform API.\n * If an error occurs, throws with detailed info from try.\n * @returns stringTransform API.\n */\nfunction stringTransformStart() {\n  let errorInfo: { error: Error; step: string; valueSoFar: string } | null =\n    null;\n  const result = tryFn((error, step, valueSoFar) => {\n    errorInfo = { error, step, valueSoFar };\n  });\n  if (result === null && errorInfo) {\n    const { error, step, valueSoFar } = errorInfo;\n    throw new Error(\n      `Assertion failed at step \"${step}\": ${(error as Error).message}\\nValue so far: ${valueSoFar}`,\n    );\n  }\n\n  if (!result) {\n    throw new Error(`Assertion failed at step \"${steps.pop()?.name}\"`);\n  }\n\n  return stringTransform(currentValue);\n}\n\n/**\n * Initiates a Regist assertion API for string validation.\n *\n * @param stringToValidate The string to validate.\n * @returns An API with assertion methods for chaining.\n *\n * @example\n * assertThat(\"foo\").has(\"oo\").isNot().isExactly(\"bar\").try();\n * // → false\n *\n * @example\n * assertThat('fooBar')\n *   .has('Bar')\n *   .isAlpha()\n *   .try((error, step, valueSoFar) => {\n *     console.error(error, step, valueSoFar);\n *   }); // handles error and returns null\n *\n * @example\n * assertThat('fooBar')\n *   .has('foo')\n *   .stringTransform()\n *   .toUpperCase()\n *   .try();\n * // → \"FOOBAR\"\n */\nexport function assertThat(stringToValidate: string) {\n  // reset working state for new assertion chain\n  steps.length = 0;\n  _negate = false;\n  currentValue = stringToValidate;\n  return api;\n}\n"]}